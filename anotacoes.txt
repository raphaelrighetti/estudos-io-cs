============CAMINHOS DE ARQUIVOS============

O C# irá sempre olhar dentro da pasta do arquivo executável de dabug quando executamos um projeto C# dentro do VisualStudio, ou seja, dentro da pasta "bin\Degub\net6.0".

Se temos um arquivo dentro dessa pasta, nem precisamos passar o caminho todo até ele, basta colocarmos o nome do arquivo como path para acessá-lo, que o C# já irá encontrá-lo dentro dessa pasta para nós.

============FileStream============

É uma classe que nos permite criar um fluxo de dados em um arquivo (read & write).

============Read(<buffer>, <offset>, <count>)============

É o método que utilizamos para ler o conteúdo de um fluxo de dados, como um FileStream, por exemplo.

Recebe um "byte[]" como primeiro parâmetro, que é um array de bytes que será usado como buffer, para ir armazenando os dados recebidos do fluxo que serão usados. Normalmente o buffer terá 1024 posições, pois esse é o número de bytes que existem em 1KB.

Como segundo parâmetro, recebe o offset, que representa de qual índice do buffer a leitura deve começar.

Como terceiro parâmetro, recebe quantos bytes do buffer ele irá utilizar, que será o "buffer.Length" na maioria dos casos.

O método "Read()" retorna um número inteiro que representa o número de bytes que foram lidos e inseridos no buffer, sendo 0 quando não há mais nenhum byte a ser lido. Podemos utilizar isso para fazer uma leitura dinâmica por todo o nosso arquivo, sem precisar ter um buffer do tamanho exato do arquivo com qual estamos trabalhando.

Sempre que executamos o método "Read()" ele irá começar a leitura a partir do último ponto que ele parou na última leitura, por isso conseguimos utilizá-lo em um while para ler o arquivo todo com um buffer menor do que o tamanho do arquivo.

============IDisposable============

É a interface que contém o método "Dispose()", que é o responsável por descartar a referência que não será mais utilizada. Fluxos de dados e classes que fazem requisições para lugares externos normalmente implementam essa interface.

O método "Dispose()" chama o método "Close()", que é o método que irá encerrar completamente a referência em questão.

Podemos garantir que nossa referência "IDisposable" será descartada utilizando ela dentro de um "using ()". Podemos fazer a mesma coisa manualmente usando um "try / catch / finally".

O "using ()" também verifica se a referência "IDisposable" que estamos abrindo não é nula com um try / catch elaborado especificamente para isso, por isso não precisamos fazer esse tratamento quando usamos um bloco de código "using ()".

============ENUM============

Existem enums no C# e funcionam da mesma maneira que no Java.

============UTF8Encoding============

É uma classe que nos permite trabalhar com encoding para UTF-8.

Possui métodos como o "GetString(<byte[]>)", que nos retorna uma string no respeitando a tabela unicode a partir de um array de bytes (ou buffer), usando o encoder UTF-8.

O método "GetString()" também aceita mais dois argumentos além do buffer, que são o índice no qual ele vai iniciar a conversão no buffer e a quantidade de bytes que ele vai ler do buffer. Usando esses dois argumentos, não precisamos limpar o buffer a cada "Read()" feito nele, pois podemos passar que ele só deve converter os bytes em string até o número de bytes que foram lidos pelo método "Read()", que fica acessível no retorno do método. Assim, mesmo tendo bytes repetidos mais ao final do buffer, eles não serão convertidos e não teremos informações repetidas no nosso texto.

============partial class============

Uma "partial class" é uma classe que é dividida em mais de um arquivo e junta na compilação, funcionando como se a classe estivesse inteira em um arquivo só.

Para termos uma partial class, basta usar a palavra chave "partial" em todas as definições daquela mesma classe.

Isso é útil em situações em que estamos lidando com classes geradas automaticamente, onde coisas podem mudar e podemos perder o nosso trabalho caso a classe seja gerada novamente. Nesse caso, podemos ter uma classe parcial e escrever nosso código fora da classe gerada automaticamente, de forma que não perderíamos o nosso trabalho caso a classe fosse gerada novamente com alguma alteração.

Se uma classe está ficando muito grande e pensamos em usar um partial apenas para deixá-la mais legível, isso é sinal que a nossa classe está com mais responsabilidades do que deveria, o que não é bom. Em casos assim devemos criar outras classes para dividir as responsabilidades.

============StreamReader============

É uma classe que nos ajuda a fazer a leitura de streams de maneira mais fácil e de alto nível.

Recebe um Stream em sua construção e possui métodos e propriedades que auxiliam na manipulação do nosso fluxo de dados.

Exemplos:

    "ReadLine()":
        Lê uma linha do nosso Stream. Pula para a próxima linha a cada execução do método.

    "ReadToEnd()":
        Carrega o nosso Stream inteiro sem um buffer e mostra tudo que tem nele decodificando os bytes (pode ser uma má ideia).

    "Read()":
        Lê um byte apenas do nosso Stream.

    "EndOfStream":
        Retorna um bool informando se o Stream está no final ou não. Útil para ser usado em um loop para percorrer o Stream todo sem carregá-lo completo de uma vez.

Usando o StreamReader temos muito mais facilidade para trabalhar com fluxos de dados.

É importante lembrar que quando utilizamos o "using ()", não precisamos nos preocupar em fechar os objetos criados com o objeto temporário do bloco de código, pois todos serão fechados juntamente com ele.
